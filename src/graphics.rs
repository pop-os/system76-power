use std::{fs, io, process};
use std::io::Write;

use config::AmdSettings;
use module::Module;
use pci::PciBus;
use sysfs_class::{PciDevice, SysClass};

static MODPROBE_NVIDIA: &'static [u8] = br#"# Automatically generated by system76-power
"#;

static MODPROBE_INTEL: &'static [u8] = br#"# Automatically generated by system76-power
blacklist nouveau
blacklist nvidia
blacklist nvidia-drm
blacklist nvidia-modeset
alias nouveau off
alias nvidia off
alias nvidia-drm off
alias nvidia-modeset off
"#;

pub struct Graphics {
    pub bus: PciBus,
    pub amd: Vec<PciDevice>,
    pub intel: Vec<PciDevice>,
    pub nvidia: Vec<PciDevice>,
    pub nvidia_hda: Vec<PciDevice>,
    pub other: Vec<PciDevice>,
}

impl Graphics {
    pub fn new() -> io::Result<Graphics> {
        let bus = PciBus::new()?;

        info!("Rescanning PCI bus");
        bus.rescan()?;

        let mut amd = Vec::new();
        let mut intel = Vec::new();
        let mut nvidia = Vec::new();
        let mut nvidia_hda = Vec::new();
        let mut other = Vec::new();

        for dev in PciDevice::all()? {
            let c = dev.class()?;
            match (c >> 16) & 0xFF {
                0x03 => match dev.vendor()? {
                    0x1002 => {
                        info!("{}: AMD graphics", dev.id());
                        amd.push(dev);
                    }
                    0x10DE => {
                        info!("{}: NVIDIA graphics", dev.id());
                        nvidia.push(dev);
                    },
                    0x8086 => {
                        info!("{}: Intel graphics", dev.id());
                        intel.push(dev);
                    },
                    vendor => {
                        info!("{}: Other({:X}) graphics", dev.id(), vendor);
                        other.push(dev);
                    },
                },
                0x04 => match (c >> 8) & 0xff {
                    0x03 => match dev.vendor()? {
                        0x10DE => {
                            info!("{}: NVIDIA audio", dev.id());
                            nvidia_hda.push(dev);
                        },
                        _ => ()
                    },
                    _ => ()
                },
                _ => ()
            }
        }

        Ok(Graphics {
            bus,
            amd,
            intel,
            nvidia,
            nvidia_hda,
            other,
        })
    }

    pub fn can_switch(&self) -> bool {
        !self.intel.is_empty() && !self.nvidia.is_empty()
    }

    pub fn get_vendor(&self) -> io::Result<String> {
        let modules = Module::all()?;
        let vendor = if modules.iter().any(|module| module.name == "nouveau" || module.name == "nvidia") {
            "nvidia".to_string()
        } else {
            "intel".to_string()
        };

        Ok(vendor)
    }

    pub fn set_vendor(&self, vendor: &str) -> io::Result<()> {
        if self.can_switch() {
            {
                let path = "/etc/modprobe.d/system76-power.conf";
                info!("Creating {}", path);
                let mut file = fs::OpenOptions::new()
                    .create(true)
                    .truncate(true)
                    .write(true)
                    .open(path)?;

                if vendor == "nvidia" {
                    file.write_all(MODPROBE_NVIDIA)?;
                } else {
                    file.write_all(MODPROBE_INTEL)?;
                }

                file.sync_all()?;
            }

            if vendor == "nvidia" {
                info!("Enabling nvidia-fallback.service");
                let status = process::Command::new("systemctl").arg("enable").arg("nvidia-fallback.service").status()?;
                if ! status.success() {
                    // Error is ignored in case this service is removed
                    error!("systemctl: failed with {}", status);
                }
            } else {
                info!("Disabling nvidia-fallback.service");
                let status = process::Command::new("systemctl").arg("disable").arg("nvidia-fallback.service").status()?;
                if ! status.success() {
                    // Error is ignored in case this service is removed
                    error!("systemctl: failed with {}", status);
                }
            }

            info!("Updating initramfs");
            let status = process::Command::new("update-initramfs").arg("-u").status()?;
            if ! status.success() {
                return Err(io::Error::new(
                    io::ErrorKind::Other,
                    format!("update-initramfs: failed with {}", status)
                ));
            }

            Ok(())
        } else {
            Err(io::Error::new(
                io::ErrorKind::Other,
                "does not have switchable graphics"
            ))
        }
    }

    pub fn get_power(&self) -> io::Result<bool> {
        if self.can_switch() {
            Ok(self.nvidia.iter().chain(self.nvidia_hda.iter()).any(|dev| dev.path().exists()))
        } else {
            Err(io::Error::new(
                io::ErrorKind::Other,
                "does not have switchable graphics"
            ))
        }
    }

    pub fn set_power(&self, power: bool) -> io::Result<()> {
        if self.can_switch() {
            if power {
                info!("Enabling graphics power");
                self.bus.rescan()?;
            } else {
                info!("Disabling graphics power");

                // Unbind NVIDIA audio devices
                for dev in self.nvidia_hda.iter() {
                    if dev.path().exists() {
                        match dev.driver() {
                            Ok(driver) => {
                                info!("{}: Unbinding {}", driver.id(), dev.id());
                                unsafe { driver.unbind(&dev) };
                            },
                            Err(err) => match err.kind() {
                                io::ErrorKind::NotFound => (),
                                _ => return Err(err),
                            }
                        }
                    }
                }

                // Remove NVIDIA graphics and audio devices
                for dev in self.nvidia.iter().chain(self.nvidia_hda.iter()) {
                    if dev.path().exists() {
                        match dev.driver() {
                            Ok(driver) => {
                                error!("{}: in use by {}", dev.id(), driver.id());
                                return Err(io::Error::new(
                                    io::ErrorKind::Other,
                                    "device in use"
                                ));
                            },
                            Err(err) => match err.kind() {
                                io::ErrorKind::NotFound => {
                                    info!("{}: Removing", dev.id());
                                    unsafe { dev.remove() }?;
                                },
                                _ => return Err(err),
                            }
                        }
                    } else {
                        warn!("{}: Already removed", dev.id());
                    }
                }
            }
            Ok(())
        } else {
            Err(io::Error::new(
                io::ErrorKind::Other,
                "does not have switchable graphics"
            ))
        }
    }

    pub fn auto_power(&self) -> io::Result<()> {
        self.set_power(self.get_vendor()? == "nvidia")
    }

    pub fn set_power_profile(&self, profile: u8) -> io::Result<()> {
        let mut errored = false;

        macro_rules! try {
            ($path:expr, $value:expr) => (
                match fs::OpenOptions::new().write(true).open($path) {
                    Ok(mut file) => {
                        if let Err(why) = file.write_all($value.as_bytes()) {
                            warn!("failed to write {} to {}: {}", $value, $path.display(), why);
                            errored = true;
                        }
                    }
                    Err(why) => {
                        warn!("failed to open {} for writing: {}", $path.display(), why);
                        errored = true;
                    }
                }
            )
        }

        let amd_profile = match profile {
            0 => AmdSettings::battery(),
            1 => AmdSettings::balanced(),
            _ => AmdSettings::performance()
        };

        for amd_gpu in &self.amd {
            info!("Setting graphics power profile ({}) for {}", profile, amd_gpu.path().display());
            let dpm_state = amd_gpu.path().join("power_dpm_state");
            let dpm_force_perf = amd_gpu.path().join("power_dpm_force_performance_level");
            let power_method = amd_gpu.path().join("power_method");
            let power_profile = amd_gpu.path().join("power_profile");

            try!(&dpm_state, amd_profile.dpm_state);
            try!(&dpm_force_perf, amd_profile.dpm_perf);
            try!(&power_method, "profile");
            try!(&power_profile, amd_profile.profile);
        }

        // TODO: Support NVIDIA, Nouveau, and AMDGPU Pro.

        if errored {
            Err(io::Error::new(io::ErrorKind::Other, "failures occurred when setting parameters"))
        } else {
            Ok(())
        }
    }
}
